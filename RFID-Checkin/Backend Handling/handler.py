from googleapiclient.discovery import build
from google.oauth2 import service_account
import paho.mqtt.client as mqtt
import paho.mqtt.publish as publish
import node, log, rfidtag, re, json, pickle, io, datetime, threading, time

#region Variable Initialization
SCOPES = ['https://www.googleapis.com/auth/spreadsheets'] # Read and write permissions for program
SPREADSHEET_ID = '1qrFQxaisVqFPFmdBzI8MSJnH-PSuc9i2sePcdpA0_PI' # Spreadsheet ID for list of ids, names, and clubs

NODES_RANGE = 'readers!a2:b'
STATUS_RANGE = 'ids!a2:f'
LOGS_RANGE = 'log!a2:g'

HANDLER_FILE = 'data/handler.rsf'
LOG_FILE = 'data/logs.txt'
SERVICE_ACCOUNT_FILE = 'data/service_account.json'

nodes = []
rfid_tags = []
logs = []

log_stream = None
status_stream = None

sheet_update_running = False
#endregion

#region Client Handling
def on_message(client, data, msg):
  '''
  Appends new logs from the JSON file received.

  Unpacks the data (in JSON format) into a Python object, finds out which node the message came from,
  creates a new log object, updates the rfid tags list with new log data, and appends the log
  object to the log file.
    
  Args:
    client: client, the client instance for this callback
    data: string, userdata on the call
    message: an instance of MQTTMessage. This is a class with members topic, payload, qos, retain. Formatted as follows:\n
      [
        {
            "EPC": {epc},
            "Time": {timestamp},
            "Status": {status of tag},
            "RSSI": {strength of the tag signal}
        },
        ...
      ]
  '''


  js = json.loads(str(msg.payload, 'utf-8')) # Deserialize JSON object to Python Object to allow for manipulation
  curr_node = next(n for n in nodes if n.id == re.search('\/(.+)\/', msg.topic).group(1)) # Find out which unit this call came from
  
  for item in js: 
    curr_tag_index = rfid_tags.index(next(t for t in rfid_tags if t.EPC == item['EPC'])) # Get index of the RFID tag associated with the log
    rfid_tags[curr_tag_index].Node = curr_node # Update the tag's current Node
    rfid_tags[curr_tag_index].Status = rfidtag.Status(item['Status']) # Update the tag's status

    # Create the new log object and add it to the database
    new_log = log.Log(rfid_tags[curr_tag_index], datetime.datetime.strptime(item['Time'], "%Y-%m-%dT%H:%M:%S.%f"), curr_node)
    logs.append(new_log)

    update_log_file(new_log)
    save_setup_file()

def on_connect(client, data, flags, rc):
  # Connects to every Node
  for n in nodes:
    client.subscribe('reader/{}/active_tag'.format(n.ID), 1) # Listener for updates on 'reader/{n.ID}/active_tag' topic
    publish.single('reader/{}/status'.format(n.ID), payload=b'read', qos=1, hostname="broker.hivemq.com", port=8000, transport="websockets") # Tell all readers to begin reading

def disconnect(client):
  '''
  Tells all nodes to stop reading and disconnects the MQTT client.

  Args:
    client: client, the client object generated by MQTT library.
  '''

  # Sends every Node a 'stop' message.
  for n in nodes:
    publish.single('reader/{}/status'.format(n.ID), payload=b'stop', qos=1, hostname="broker.hivemq.com", port=8000, transport="websockets")
  client.disconnect()
#endregion

#region File Handling
def update_log_file(log):
  '''
  Appends to the log file a new instance.

  Args:
    log: Log, the log object to be appended.
  '''

  with open(LOG_FILE, mode='a') as hf:
    hf.write(str(log))

def save_setup_file():
  '''
  Saves the current nodes and RFID tags into the handler file.
  '''

  # Creates wrapper of the data generated from the nodes, rfid_tags, and logs lists, pickles, and saves to HANDLER_FILE
  pickle.dump([nodes, rfid_tags], open(HANDLER_FILE, mode='wb'))

def save_sheet(service):
  '''
  Updates the spreadsheet with current values inside of nodes, rfid_tags, and logs

  Args:
    service: resource, object generated by the GOAuth API 
  '''

  # GSheets API wants an array of values, so we create a series of the following object associated with all nodes, rfid tags, and logs
  # [
  #   [
  #     [val_0_0], [val_0_1], ...
  #   ],
  #   [
  #     [val_1_0], [val_1_1], ...
  #   ],
  #   ....
  # ]
  node_vals = list(map(lambda n: [[n.ID], [n.Location]], nodes))
  rfid_tag_vals = list(map(lambda r: [[r.EPC], [str(r.Status)], [r.Owner], [r.Description], [r.Node.Location], [r.Extra]], rfid_tags))
  log_vals = list(map(lambda l: [[l.Timestamp], [str(l.Status)], [l.EPC], [l.Description], [l.Node.Location], [l.Extra]], logs))


  # Tell GSheets that we want to it to post our data by column
  node_resource = {
    "majorDimension": "COLUMNS",
    "values": node_vals
  }

  rfid_tags_resource = {
    "majorDimension": "COLUMNS",
    "values": rfid_tag_vals
  }

  logs_resource = {
    "majorDimension" : "COLUMNS",
    "values" : log_vals
  }

  # Send GSheets to execute update request with RAW input (meaning GSheets will not perform any 
  # extra formatting on the data. This prevents the program from having to understand multiple formats).
  service.spreadsheets().values().update(spreadsheetId=SPREADSHEET_ID, range=NODES_RANGE, body=node_resource, valueInputOption="RAW").execute()
  service.spreadsheets().values().update(spreadsheetId=SPREADSHEET_ID, range=STATUS_RANGE, body=rfid_tags_resource, valueInputOption="RAW").execute()
  service.spreadsheets().values().update(spreadsheetId=SPREADSHEET_ID, range=LOGS_RANGE, body=logs_resource, valueInputOption="RAW").execute()

def load_setup_file(data):
  '''
  Loads nodes and rfid tags from the unpickled data.

  Args:
    data: string, text read from the setup file. Should be formatted as follows:\n
          [List<node.Node>, List<rfidtag.RFIDTag>]
  '''

  global nodes
  global rfid_tags

  obj = pickle.loads(data)

  nodes = obj[0]
  rfid_tags = obj[1]
  
def load_sheets(service):
  '''
  Retrieves nodes, rfid tags, and logs from the spreadsheet.

  Args:
    service: resource, object generated by the GOAuth API
  '''

  global nodes
  global rfid_tags
  global logs

  # Get nodes from spreadsheet
  node_values = service.spreadsheets().values().get(spreadsheetId=SPREADSHEET_ID, range=NODES_RANGE).execute().get('values', [])
  nodes = list(map(lambda val: node.Node(val[0], val[1]), node_values))

  # Get status from spreadsheet
  status_values = service.spreadsheets().values().get(spreadsheetId=SPREADSHEET_ID, range=STATUS_RANGE).execute().get('values', [])
  rfid_tags = list(map(lambda val: rfidtag.RFIDTag(val[0], rfidtag.Status[val[1]], val[2], val[3], next(n for n in nodes if n.Location == str(val[4])), val[5]), status_values))

  # Get logs from spreadsheet
  log_values = service.spreadsheets().values().get(spreadsheetId=SPREADSHEET_ID, range=LOGS_RANGE).execute().get('values', [])
  logs = list(map(lambda val: log.Log(next(tag for tag in rfid_tags if tag.EPC == val[2]), datetime.datetime.strptime(val[0], "%Y-%m-%dT%H:%M:%S.%fZ"), next(n for n in nodes if n.Location == val[5])), log_values))
#endregion

def automatic_sheet_update(service, updates = 6):
  '''
  Updates the GSheets file periodically

  Args:
    service: resource, object generated by the GOAuth API
    update: int, amount of sheet updates per day.
  '''
  while sheet_update_running:
    save_sheet(service)
    time.sleep((24 / updates) * 3600)

if __name__ == '__main__':
  '''
  Setup for the handling of the tags received from each Node.
  
  Logs into GOAuth, opens and reads data files, starts automatic sheet update service, creates MQTT client.
  Catches KeyboardInterrupt to kill the program safely
  '''

  # Login to GSheets service
  creds = service_account.Credentials.from_service_account_file(SERVICE_ACCOUNT_FILE, scopes=SCOPES) # Generate credentials object from service account file
  service = build('sheets', 'v4', credentials=creds) # Create service object

  rsf_data = None
  rld_data = None
  # Attempts to open the handler and log file, creating the file if need be.
  with open(HANDLER_FILE, mode='a+b') as hf:
    rsf_data = hf.read()
  with open(LOG_FILE, mode='a') as lf:
    lf.write("Timestamp\tStatus\tEPC\tOwner\tDescription\tLocation\tExtra")

  # If the handler file is empty, pull data from GSheets, otherwise use data stored locally
  if rsf_data == b'':
    load_sheets(service)
    save_setup_file()
  else:
    load_setup_file(rsf_data)
    
  sheet_update_running = True
  threading.Thread(target=automatic_sheet_update, args=(service, 6)).start()

  client = mqtt.Client(transport='websockets') # Connect with websockets
  client.on_connect = on_connect
  client.on_message = on_message
  client.connect('broker.hivemq.com', port=8000)

  try:
    client.loop_forever()
  except KeyboardInterrupt:
    sheet_update_running = False
    save_setup_file()
    disconnect(client)